import pprint
from subprocess import Popen

from function import FunctionTemplate, FunctionArgument, MacroDefinition
from header import Header
from struct import Struct
from sql_types import SqlType, SqlColumn
from datetime import datetime as dt
import os
import json


def main():
	inp_file = "library_def.sql"
	name = os.path.splitext(inp_file)[0]
	node = Popen(["node", "index.js", inp_file])
	node.wait()
	assert node.returncode == 0

	with open(name + ".json", "r") as file:
		json_string = file.read()

	json_data = json.loads(json_string)
	structs = []
	pprint.pprint(json_data)
	pprint.pprint(len(json_data))
	for table in json_data:
		struct_name = table["name"]
		structs_members = []
		for column in table["columns"]:
			col_name = column["name"]
			col_type = column["type"]["datatype"]
			col_type_sql = None
			err_msg = f"Failed parsing '{col_name}' for struct '{struct_name}'."

			if "length" in column["type"].keys():
				col_size = column["type"]["length"]
			elif "width" in column["type"].keys():
				col_size = column["type"]["width"]
			else:
				col_size = 56

			if {"column": col_name} in table["primaryKey"]["columns"]:
				col_type_sql = SqlType.PK_LONG
			elif col_type == "varchar":
				col_type_sql = SqlType.VARCHAR
			elif col_type == "int":
				col_type_sql = SqlType.LONG

			if "foreignKeys" in table.keys():
				if {"column": col_name} in [fk["columns"][0] for fk in table["foreignKeys"]]:
					# if col_type_sql != SqlType.PK_LONG:
					col_type_sql = SqlType.FK_LONG

			# assert col_type_sql is not None, err_msg
			if col_type_sql is not None:
				structs_members.append(SqlColumn(col_name, col_type_sql, col_size))
		print(struct_name, structs_members)
		structs.append(Struct(struct_name, structs_members))

	for struct in structs:
		save_to_file(struct)
		print(struct.name.upper() + "_E")


# save_to_file(region)
# save_to_file(library)
# save_to_file(address)


def save_to_file(struct: Struct):
	"""
	Saves all structs methods to file '{name}.c'.
	"""
	out_dir = ".."
	insert_func = declaration_insert(struct)
	struct.methods.append(insert_func)
	execute_find_func = declaration_execute_find(struct)
	struct.methods.append(execute_find_func)
	find_by_id_func = declaration_find_by_id(struct)
	struct.methods.append(find_by_id_func)
	update_func = declaration_update(struct)
	struct.methods.append(update_func)
	execute_func = declaration_execute(struct)
	struct.methods.append(execute_func)
	delete_func = declaration_delete(struct)
	struct.methods.append(delete_func)

	body_execute_find(struct, execute_find_func)
	body_insert(struct, insert_func)
	if struct.get_pk() is not None:
		body_find_by_id(struct, find_by_id_func)
	body_update(struct, update_func)
	body_execute(struct, execute_func)
	body_delete(struct, delete_func)

	file_header = ("/**\n"
	               " * Generated by {user} on {time}\n"
	               " */\n"
	               ).format(user=os.getlogin(), time=dt.now().strftime("%d/%m/%Y")).lstrip("\t").rstrip("\t")
	from os.path import exists
	if not exists(out_dir + "/src"):
		os.mkdir(out_dir + "/src")
	if not exists(out_dir + "/src/db"):
		os.mkdir(out_dir + "/src/db")
	if not exists(out_dir + "/src/db/orm"):
		os.mkdir(out_dir + "/src/db/orm")
	with open(out_dir + "/src/db/orm/{name}.c".format(name=struct.name), "w") as file:
		file.write(file_header)
		file.write("\n#include \"db/orm/entity.h\"\n\n\n")
		file.write(str(insert_func))
		file.write(str(execute_find_func))
		file.write(str(find_by_id_func))
		file.write(str(update_func))
		file.write(str(execute_func))
		file.write(str(delete_func))
	if not exists(out_dir + "/internal"):
		os.mkdir(out_dir + "/internal")
	if not exists(out_dir + "/internal/db"):
		os.mkdir(out_dir + "/internal/db")
	if not exists(out_dir + "/internal/db/orm"):
		os.mkdir(out_dir + "/internal/db/orm")
	with open(out_dir + "/internal/db/orm/{name}.h".format(name=struct.name), "w") as file:
		file.write(file_header)
		file.write(genereate_h(struct))


def genereate_h(struct: Struct):
	return str(Header(struct))


def insert_sql_string(struct: Struct):
	"""
	Generates 'INSERT' SQL command for respective struct.
	"""
	return f'insert into {struct.name} ({", ".join([param.name for param in struct.get_params()])}) values ({", ".join(("?" * struct.param_count()))});'


def update_sql_string(struct: Struct):
	"""
	Generates 'UPDATE' SQL command for respective struct.
	"""
	# noinspection SqlResolve
	return f'update {struct.name} set {", ".join([param.name + " = ?" for param in struct.get_params()])} where id_{struct.name} = ?;'


def find_by_id_sql_string(struct: Struct):
	"""
	Generates 'SELECT' SQL command for respective struct that finds by ID.
	"""
	# noinspection SqlResolve
	return f'select * from {struct.name} where id_{struct.name} = ?;'


def delete_sql_string(struct: Struct):
	"""
	Generates 'DELETE' SQL command for respective struct that deletes by ID.
	"""
	# noinspection SqlResolve
	return f'delete from {struct.name} where id_{struct.name} = ?;'


def declaration_execute_find(struct: Struct):
	arg_list = [FunctionArgument("char const*", "query"),
	            FunctionArgument("MYSQL_BIND*", "params"),
	            FunctionArgument("uint", "param_count")]
	func = FunctionTemplate("{name}_execute_find".format(name=struct.name), "SQL_RESULT*", arg_list)
	return func


def body_execute_find(struct: Struct, func: FunctionTemplate):
	func.add_macro_def(MacroDefinition("QUERY_SIZE", "512"))
	func.add_macro_def(MacroDefinition("RES_COL_COUNT", str(struct.col_count())))
	func.add_macro_def(MacroDefinition("BUFFER_SIZE", "255"))
	func.add_block("""MYSQL* __attribute__((cleanup(mysql_con_cleanup))) conn;
		SQL_RESULT* res;
		MYSQL_RES* prepare_meta_result;
		MYSQL_STMT* stmt;""")
	func.add_block(struct.get_col_buffer_definitions())
	func.add_block("""conn = db_init();
			stmt = mysql_stmt_init(conn);
		""")
	func.add_block("""if (mysql_stmt_prepare(stmt, query, strnlen(query, QUERY_SIZE))) {
				fprintf(stderr, " mysql_stmt_prepare(), SELECT failed\\n");
				fprintf(stderr, " %s\\n", mysql_stmt_error(stmt));
				return NULL;
			}
			mysql_stmt_bind_param(stmt, params);
			assert(param_count == mysql_stmt_param_count(stmt));""")
	func.add_block("""/* Fetch result set meta information */
			prepare_meta_result = mysql_stmt_result_metadata(stmt);
			if (!prepare_meta_result) {
				fprintf(stderr, " mysql_stmt_result_metadata(), returned no meta information\\n");
				fprintf(stderr, " %s\\n", mysql_stmt_error(stmt));
				return NULL;
			}
			assert(RES_COL_COUNT == mysql_num_fields(prepare_meta_result));""")
	func.add_block("""/* Execute the SELECT query */
		if (mysql_stmt_execute(stmt)) {
			fprintf(stderr, " mysql_stmt_execute(), failed\\n");
			fprintf(stderr, " %s\\n", mysql_stmt_error(stmt));
			return NULL;
		}""")
	func.add_block(struct.get_buffer_bindings())
	func.add_block("""/* Bind the result buffers */
		if (mysql_stmt_bind_result(stmt, param)) {
			fprintf(stderr, " mysql_stmt_bind_result() failed\\n");
			fprintf(stderr, " %s\\n", mysql_stmt_error(stmt));
			return NULL;
		}""")
	func.add_block("""/* Now buffer all results to client (optional step) */
		if (mysql_stmt_store_result(stmt)) {
			fprintf(stderr, " mysql_stmt_store_result() failed\\n");
			fprintf(stderr, " %s\\n", mysql_stmt_error(stmt));
			return NULL;
		}""")
	func.add_block("""/* Fetch all rows */
			struct sql_result_row* row = NULL;
			struct sql_result_row* curr = NULL;
		
			res = calloc(1, sizeof(SQL_RESULT));
			res->results = NULL;
			res->type = {enum_name};
			res->count = 0;""".format(enum_name=struct.enum_name))
	func.add_block(struct.col_fetch())
	func.add_block("""/* Free the prepared result metadata */
			mysql_free_result(prepare_meta_result);
			if (mysql_stmt_close(stmt)) {
				fprintf(stderr, " failed while closing the statement\\n");
				fprintf(stderr, " %s\\n", mysql_error(conn));
				mysql_res_free(&res);
				return NULL;
			}""")
	func.add_block("return res;")


def declaration_find_by_id(struct: Struct):
	arg_list = [FunctionArgument("uint", "id")]
	return FunctionTemplate("{}_find_by_id".format(struct.name), "{}*".format(struct.typedef_name), arg_list)


def body_find_by_id(struct: Struct, func: FunctionTemplate):
	func.add_macro_def(MacroDefinition("QUERY", '"{}"'.format(find_by_id_sql_string(struct))))
	func.add_macro_def(MacroDefinition("PARAM_COUNT", "1"))
	func.add_block("{}* out;".format(struct.typedef_name))
	func.add_block("""
			SQL_RESULT* res;
			struct {name} {name};
			{name}.{pk_name} = id;
			struct {name}* {name}T = &{name};
			""".format(name=struct.name, pk_name=struct.get_pk().name))
	func.add_block(struct.get_col_param_buffer(["id_{}".format(struct.name)]))
	func.add_block("res = {}_execute_find(QUERY, param, PARAM_COUNT);".format(struct.name))
	func.add_block(struct.col_param_buffer_free(1))
	func.add_block("""out = res->results->data;
			if (res->count == 1) {{
				free(res->results);
				free(res);
				return out;
			}} else {{
				fprintf(stderr, "{name}_execute_find(), failed - multiple results (%d)\\n", res->count);
				mysql_res_free(&res);
				return NULL;
			}}""".format(name=struct.name))
	return func


def declaration_insert(struct: Struct):
	arg_list = [FunctionArgument("{}*".format(struct.typedef_name), "{}T".format(struct.name))]
	return FunctionTemplate("{}_insert".format(struct.name), "uint", arg_list)


def body_insert(struct: Struct, func: FunctionTemplate):
	func.add_macro_def(MacroDefinition("QUERY_LENGTH", "512"))
	func.add_macro_def(MacroDefinition("STRING_SIZE", "255"))
	func.add_macro_def(MacroDefinition("QUERY", '"{}"'.format(insert_sql_string(struct))))
	func.add_macro_def(MacroDefinition("PARAM_COUNT", "{}".format(struct.param_count())))
	func.add_block(struct.get_insert_assertions())
	func.add_block("""MYSQL* __attribute__((cleanup(mysql_con_cleanup))) conn;
				MYSQL_STMT* __attribute__((cleanup(mysql_stmt_cleanup))) stmt;
				uint retval;
				""")
	func.add_block("""conn = db_init();
				stmt = mysql_stmt_init(conn);""")
	func.add_block(struct.get_update_fk())
	func.add_block(struct.col_param_lengths(func))
	func.add_block(struct.get_col_param_buffers())
	func.add_block("""if (mysql_stmt_prepare(stmt, QUERY, QUERY_LENGTH)) {
					fprintf(stderr, " mysql_stmt_prepare(), failed\\n");
					fprintf(stderr, " %s\\n", mysql_stmt_error(stmt));
					return 0U;
					}""")
	func.add_block("""if (mysql_stmt_bind_param(stmt, param)) {
					fprintf(stderr, " mysql_stmt_bind_param(), failed\\n");
					fprintf(stderr, " %s\\n", mysql_stmt_error(stmt));
					return 0U;
				}""")
	func.add_block("""if (mysql_stmt_execute(stmt)) {
					fprintf(stderr, " mysql_stmt_execute(), failed\\n");
					fprintf(stderr, " %s\\n", mysql_stmt_error(stmt));
					return 0U;
				}""")
	func.add_block("retval = (uint) mysql_stmt_insert_id(stmt);")
	if struct.get_pk() is not None:
		func.add_block(("// update id after insertion;\n"
		                "{name}T->{pk} = retval;\n").format(name=struct.name, pk=struct.get_pk().name))
	func.add_block(struct.col_param_buffer_free())
	func.add_block("return retval;")
	return func


def declaration_update(struct: Struct):
	arg_list = [FunctionArgument("{}*".format(struct.typedef_name), "{}T".format(struct.name))]
	return FunctionTemplate("{}_update".format(struct.name), "int", arg_list)


def body_update(struct: Struct, func: FunctionTemplate):
	if struct.get_pk() is not None:
		func.add_block("assert({name}T->{pk_name} != 0);".format(name=struct.name, pk_name=struct.get_pk().name))
	func.add_macro_def(MacroDefinition("QUERY", '"{}"'.format(update_sql_string(struct))))
	func.add_macro_def(MacroDefinition("PARAM_COUNT", str(struct.col_count())))
	func.add_macro_def(MacroDefinition("STRING_SIZE", "255"))
	func.add_block("""int retval;""")
	func.add_block(struct.col_update_params(func))
	func.add_block("retval = {}_execute(QUERY, param, PARAM_COUNT);".format(struct.name))
	func.add_block(struct.col_buffer_free())
	func.add_block("return retval;")
	return func


def declaration_delete(struct: Struct):
	arg_list = [FunctionArgument("{}*".format(struct.typedef_name), "{}T".format(struct.name))]
	return FunctionTemplate("{}_delete".format(struct.name), "int", arg_list)


def body_delete(struct: Struct, func: FunctionTemplate):
	func.add_macro_def(MacroDefinition("QUERY", '"{}"'.format(delete_sql_string(struct))))
	func.add_macro_def(MacroDefinition("PARAM_COUNT", str(1)))
	if struct.get_pk() is not None:
		func.add_block("assert({name}T->{pk_name} != 0);".format(name=struct.name, pk_name=struct.get_pk().name))
	func.add_block("""int retval;""")
	func.add_block(struct.get_col_param_buffer(["id_{}".format(struct.name)]))
	func.add_block("retval = {}_execute(QUERY, param, PARAM_COUNT);".format(struct.name))
	func.add_block(struct.col_param_buffer_free(1))

	func.add_block("return retval;")
	return func


def declaration_execute(struct: Struct):
	arg_list = [FunctionArgument("char const*", "query"),
	            FunctionArgument("MYSQL_BIND*", "params"),
	            FunctionArgument("uint", "param_count")]
	return FunctionTemplate("{name}_execute".format(name=struct.name), "int", arg_list)


def body_execute(struct: Struct, func: FunctionTemplate):
	# func = struct.declaration_execute()
	func.add_macro_def(MacroDefinition("QUERY_LENGTH", '512'))
	func.add_block('\tMYSQL_STMT* stmt;\t\nMYSQL* __attribute__((cleanup(mysql_con_cleanup))) conn;\t\nint retval;')
	func.add_block('\tconn = db_init();\t\nstmt = mysql_stmt_init(conn);')
	func.add_block("""if ((retval = mysql_stmt_prepare(stmt, query, strnlen(query, QUERY_LENGTH)))) {
					fprintf(stderr, "mysql_stmt_prepare(), failed\\n");
					fprintf(stderr, "%s\\n", mysql_error(conn));
					return retval;
				}""")
	func.add_block("""if ((retval = mysql_stmt_bind_param(stmt, params))) {
					fprintf(stderr, "mysql_stmt_bind_param(), failed\\n");
					fprintf(stderr, "%s\\n", mysql_error(conn));
					return retval;
				}""")
	func.add_block("""if ((retval = mysql_stmt_execute(stmt))) {
					fprintf(stderr, "mysql_stmt_execute(), failed\\n");
					fprintf(stderr, "%s\\n", mysql_error(conn));
					return retval;
				}""")
	func.add_block("""if ((retval = mysql_stmt_close(stmt))) {
					fprintf(stderr, " failed while closing the statement\\n");
					fprintf(stderr, " %s\\n", mysql_error(conn));
					return retval;
				}""")
	return func


if __name__ == "__main__":
	main()
